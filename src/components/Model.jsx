/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/model.glb -o src/components/Model.jsx 
*/

import React, { useEffect, useLayoutEffect, useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useThree } from '@react-three/fiber'
import gsap from 'gsap'
import * as THREE from 'three'

export const Model = ({ activeIndex, ...props }) => {
  const { nodes, materials } = useGLTF('/models/model.glb')
  const { viewport, camera } = useThree()
  const ref = useRef()
  const prevIndexRef = useRef(-1)
  const hasEnteredRef = useRef(false)

  // Animate based on activeIndex changes
  useEffect(() => {
    if (!ref.current) return

    if (!hasEnteredRef.current) return  // <-- prevent running on mount
    if (activeIndex === prevIndexRef.current) return

    const aspect = viewport.aspect
    const isMobile = aspect < 1
    const duration = 1 // 1 second per transition

    // Define animation states for each index
    const animations = [
      // Index 0 - Initial state
      {
        rotation: { x: 0, y: -Math.PI / 4 },
        position: isMobile ? { x: 0.2, z: 0 } : { x: 0.7, z: 0 },
        camera: { z: 1.5, y: 0 }
      },
      // Index 1
      {
        rotation: { x: Math.PI / 6, y: -Math.PI * 6 / 10 },
        position: isMobile ? { x: 0.15, y: -0.18, z: 0 } : { x: 0.5, y: -0.18, z: 0.1 },
        camera: { z: 1.38, y: -0.3 }
      },
      // Index 2
      {
        rotation: { x: Math.PI / 4, y: -Math.PI / 2 },
        position: isMobile ? { x: 0.15, y: -0.25, z: 0 } : { x: 0.5, y: -0.25, z: 0.1 },
        camera: { z: 1.38, y: -0.3 }
      },
      // Index 3
      {
        rotation: { x: 0, y: -Math.PI * 3 / 4 },
        position: isMobile ? { x: 0.15, z: 0 } : { x: 0.5, z: 0 },
        camera: { z: 1.4, y: 0 }
      },
      // Index 4
      {
        rotation: { x: 0, y: -Math.PI * 3 / 4 },
        position: isMobile ? { x: 0.15, y: -0.25, z: 0 } : { x: 0.5, y: -0.25, z: 0 },
        camera: { z: 1.4, y: 0 }
      },
      // Index 5 
      {
        rotation: { x: 0, y: -Math.PI / 2 },
        position: isMobile ? { x: 0.15, z: 0 } : { x: 0.5, z: 0 },
        camera: { z: 1.4, y: 0 }
      },
      // Index 6
      {
        rotation: { x: Math.PI / 6, y: -Math.PI / 3 },
        position: isMobile ? { x: 0.15, y: -0.18, z: 0 } : { x: 0.5, y: -0.18, z: 0.1 },
        camera: { z: 1.38, y: -0.3 }
      },
      // Index 7
      {
        rotation: { x: 0, y: -Math.PI / 4 },
        position: isMobile ? { x: 0.2, z: 0 } : { x: 0.7, z: 0 },
        camera: { z: 1.5, y: 0 }
      },
    ]

    // Get target animation state (clamp to available animations)
    const targetIndex = Math.max(0, Math.min(activeIndex, animations.length - 1))
    const targetState = animations[targetIndex]

    // Animate to target state
    gsap.to(ref.current.rotation, {
      duration,
      x: targetState.rotation.x,
      y: targetState.rotation.y,
      ease: 'power2.inOut'
    })

    gsap.to(ref.current.position, {
      duration,
      x: targetState.position.x,
      z: targetState.position.z,
      y: targetState.position.y ?? -0.1,
      ease: 'power2.inOut'
    })

    gsap.to(camera.position, {
      duration,
      z: targetState.camera.z,
      y: targetState.camera.y,
      ease: 'power2.inOut'
    })

    prevIndexRef.current = activeIndex
  }, [activeIndex, camera, viewport.aspect])

  // Convert all materials to grayscale (existing)
  useEffect(() => {
    Object.values(materials).forEach((material) => {
      if (material.color) {
        const c = material.color
        let gray = c.r * 0.299 + c.g * 0.587 + c.b * 0.114

        const contrast = 1.5
        const brightness = 0.1
        gray = (gray - 0.5) * contrast + 0.5 + brightness
        gray = Math.min(Math.max(gray, 0), 1)
        material.color = new THREE.Color(gray, gray, gray)
      }

      if (material.map) {
        material.onBeforeCompile = (shader) => {
          shader.fragmentShader = shader.fragmentShader.replace(
            '#include <map_fragment>',
            `
              vec4 texelColor = texture2D(map, vMapUv);
              float gray = dot(texelColor.rgb, vec3(0.299, 0.587, 0.114));
              float contrast = 1.5;
              float brightness = 0.1;
              gray = (gray - 0.5) * contrast + 0.5 + brightness;
              gray = clamp(gray, 0.0, 1.0);
              diffuseColor *= vec4(vec3(gray), texelColor.a);
            `
          )
        }
        material.needsUpdate = true
      }
    })
  }, [materials])

  // Responsive positioning + entry animation
  useEffect(() => {
    const updatePosition = () => {
      const aspect = viewport.aspect
      let targetPos = new THREE.Vector3()
      let cameraPos = new THREE.Vector3()

      if (aspect < 1) {                       // Tablet / Mobile (portrait)
        targetPos.set(0.2, -0.1, 0)
        cameraPos.set(-0.3, 0, 1.5)
      } else if (aspect < 1.5) {              // Small laptop / landscape tablet
        targetPos.set(0.5, -0.1, 0)
        cameraPos.set(0, 0, 1.5)
      } else {                                // Desktop / wide screens
        targetPos.set(0.7, -0.1, 0)
        cameraPos.set(0.2, 0, 1.5)
      }

      // Initial off-screen position before animation
      ref.current.position.set(targetPos.x, targetPos.y - 1.5, targetPos.z)

      // Animate in on component mount
      gsap.timeline({
        onComplete: () => {
          hasEnteredRef.current = true
        }
      })
        .to(ref.current.position, {
          duration: 2,
          ease: 'power3.out',
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
        })
        .to(ref.current.rotation, {
          duration: 2,
          ease: 'power3.out',
          x: 0,
          y: -Math.PI / 4,
        }, "<") // sync position + rotation


      gsap.to(camera.position, {
        duration: 2,
        ease: 'power3.out',
        x: cameraPos.x,
        y: cameraPos.y,
        z: cameraPos.z,
      })
    }

    updatePosition()
    window.addEventListener('resize', updatePosition)
    return () => window.removeEventListener('resize', updatePosition)
  }, [viewport, camera])

  return (
    <group {...props} dispose={null} ref={ref}>
      <mesh
        geometry={nodes['tripo_node_a78418c3-2df1-4bb1-87dc-aa978a6a6054'].geometry}
        material={materials['tripo_mat_a78418c3-2df1-4bb1-87dc-aa978a6a6054']}
      />
    </group>
  )
}

useGLTF.preload('/models/model.glb')